# SHIPC2018qual
SoundHound Inc. Programming Contest 2018 -Masters Tournamentの自分の解答

解法分かってるのにCD通らなくて爆死。腹立つ。

# B
substringで切る方法が最初に思いついたが、w*n文字目だけを取り出せば良いことに気づいたのでそちらで実装した。

# C
バグ取りゲー。あまりにもひどい

ある数字と隣の数字が美しくなるための条件について考える。これは存在するならば（ある数字をnとすると）n+dとn-dの2通り存在する。存在しない場合はたいていそのどちらか、まれにどちらも持っていないことがある。

ただこの先がよくわからなかったので愚直に計算するテストプログラム(C(test).cpp)を用意してテストを行った。

その結果、一般的な場合において、美しくなる次の数がいくつ存在するかについてまとめると以下のようになることがわかった。

1. n>2\*d ならば2*d個の数字が1通りしか存在せず、残りの数字は2通り存在する。
2. n<2\*d ならば1+d > n-dが成立するので(1+d)-(n-d+1)個については美しくなる数字は存在しない。残りの数字については１通り存在する。
3. d=0ならば(m-1)/nが解となる。

これをまとめて実装すると最後のテストケースだけ通らなかった。

### 追記（解説見た）
美しくなるために必要な数字の組み合わせを全列挙すると、(1,1+d),(2,2+d),...,(n-d,n)もしくはその逆の2(n-d)個存在することが分かる。したがって2(n-d)*(m-1)/n^2が求める期待値となる。

中途半端なところまで通ったのでそのやり方に固執したのが敗因か。期待値の線形性もこのようなシチュエーションで使えるとは思わなんだ。

## 追記
小数がきちんと最後の桁まで出力できてないのが敗因だった。

今後は`cout<<fixed<<setprecision(12)<<ans<<endl;`と小数をきちんと表示するように改める。

# D
面白い問題だったが、解法自体はほぼ合っていると思われるためにきわめて不快だ。

解が単調減少になることを利用する。すなわちもし新しく使えなくなったところが直前まで使っていた両替所であった場合のみ解は減少する。このことを利用し逆から計算を行うと、新しく使えるようになった両替所を使った経路がこれまでの経路の最短路より優秀ならばそれに置き換えるべきだということになってくる。

円については1度ダイクストラすればすべての場合に対応できるようになる。各シチュエーションにおいてsnuukでダイクストラを行うと最適値を求められるがこれではO(N^2logN)かかり明らかにTLEする（した）。

ここでsnuukのダイクストラを1回で済ます方法を考えたいわけだが、このグラフは無向グラフなのですべての頂点からある終点に対する最短経路と終点からのすべての頂点への最短経路は等しくなることが分かる（始点を終点にすれば良い）。これによって計算量をO(NlogN)に落とせる。

これによって実装したプログラムはWAだった。しかしあとで他の人の解法見ても同じことをやっているようなので本当に遺憾である。

### 追記（解説見た）
やはり解説と同じやり方をしている。どうも貪欲的にやってしまったのが問題となったのだろうか。
